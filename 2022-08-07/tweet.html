<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
</head>

<body>
	<div id="v-tw">
		<div v-if="noTwData">
			<h1>Oops! 何かがおかしいようです。</h1>
			<p>tweet.jsを読み込めなかったか、表示できるデータがありませんでした。</p>
			<hr>
		</div>
		<button v-else v-on:click="ToggleReadMe">{{ShowMessage()}}</button>
		<div v-if="isReadMe">
			<h2>これは何？</h3>
				<p>Twitterのバックアップデータ「tweet.js」を画面上に表示させる簡易的なツールです。</p>
				<h2>どうやって使うの？</h2>
				<p>tweet.jsと同じフォルダにこのhtmlとvue.2.6.11.min.jsを配置してください。<br>後はお好きなブラウザでhtmlをプレビューするだけです。</p>
				<h2>注意することは？</h2>
				<p>tweet.jsはファイル名・ソースコード共に完全無加工のままでお願いします。</p>
				<h2>いじって良いの？</h2>
				<p>非営利＆個人でお楽しみください。自由なカスタマイズを想定し、余計なタグやCSSは極力付けておりません。</p>
				<h2>今後もメンテしていく？</h2>
				<p>なるべくそうするつもりです。</p>
				<h2>なんで作ったの？</h2>
				<p>忌まわしき歴史を抹消する前にバックアップをダウンロードしたからです。</p>
				<h2>n番煎じ</h2>
				<p>私はまだ煎じていなかった</p>
				<hr>
		</div>

		<!-- データバインド -->
		<div v-if="!noTwData">
			<p>{{twData.length}} 件 読み込みました。</p>

			<!-- 全件ver -->
			<div v-for="(tw,i) in twDataSorted" v-bind:id="tw.id">
				<hr>
				<p v-bind:style="styles">[{{i}}] {{formatDate(tw.created_at)}}<br>{{tw.full_text}}</p>
				<template v-if="tw.entities.urls.length > 0">
					<p v-for="url in tw.entities.urls">
						<a :href="url.expanded_url" target="_blank">{{url.display_url}}</a>
					</p>
				</template>
				<template v-if="tw.customImg && tw.customImg.length > 0">
					<a
						v-for="(tm, tmIndex) in tw.customImg"
						v-bind:key="`media-${tw.id}-${tmIndex}`"
						v-bind:href="tm"
						target="_blank"
					>
						<img
							v-bind:src="tm"
							style="width:10vw;height:10vw;object-fit: contain;"
						/>
					</a>
				</template>
				<p v-if="tw.in_reply_to_status_id"><a v-bind:href="'#' + tw.in_reply_to_status_id">返信元(#{{tw.in_reply_to_status_id}})</a></p>
			</div>

			<!-- スレッド表示ver(途中) -->
			<!-- <div v-for="(tw,i) in twDataFormatted" :key="`tw-${i}`">
				<hr>
				<p v-bind:style="styles">[{{tw.index}}] {{formatDate(tw.created_at)}}<br>{{tw.full_text}}</p>

				<template v-if="tw.entities.urls.length > 0">
					<p v-for="url in tw.entities.urls">
						<a :href="url.expanded_url" target="_blank">{{url.display_url}}</a>
					</p>
				</template>

				<details v-if="tw.childrenList.length > 0">
					<summary>返信</summary>
					<template v-for="(d,j) in tw.childrenList": key="`d-${j}`">
						<hr>
						<p v-bind:style="styles">[{{d.index}}] {{formatDate(d.created_at)}}<br>{{d.full_text}}</p>
					</template>
					<hr>
				</details>
			</div> -->
		</div>

		<!-- #idリンクで返信ジャンプする都合上、画面最下部を開けておく -->
		<div style="height: 800px;">&nbsp;</div>
	</div>
	<script>
		// window.YTD.tweet.part0の事前定義をやっておかないとundefinedで落ちます。
		window.YTD = {
			tweet: {
				part0: []
			}
		};
	</script>
	<script src="data/tweet.js"></script>
	<script>
		let vm = new Vue({
			el: '#v-tw',
			data: {
				noTwData: YTD.tweet.part0.length <= 0,
				isReadMe: YTD.tweet.part0.length <= 0,
				twData: YTD.tweet.part0,
				twDataSorted: [], // twDataを日付昇順ソートした結果
				twDataFormatted: [], // twDataSortedに返信階層を考慮した結果
				styles: {
					'white-space': 'pre-wrap'
				},
				// tweet.jsは本文を「/n」で表現しています。上記の形式を採用しないとしても折返しの対応は必要かと思われます。
			},
			mounted() {
				// 日付昇順ソートしたtweetデータを格納
				const editList = this.twData.sort(function (a, b) {
					if (new Date(a.tweet.created_at) > new Date(b.tweet.created_at)) {
						return 1;
					} else {
						return -1;
					}
				});

				editList.forEach((x, i) => {
					// 後で使うのオブジェクトを入れておく
					x.tweet.index = i;
					x.tweet.childrenList = [];
					x.tweet.childrenIdList = [];

					// 本文にurlが含まれている場合は別に表示するため消しておく
					x.tweet.entities.urls.forEach(function(val,i){
						if (x.tweet.full_text.includes(val.url)) {
							x.tweet.full_text = x.tweet.full_text.replace(val.url, '');
						}
					})

					// 画像が含まれる場合はパスのリストを作っておく
					if (x.tweet.extended_entities && x.tweet.extended_entities.media && x.tweet.extended_entities.media.length > 0) {
						console.log(`${x.tweet.index}: extended_entities`);
						x.tweet.customImg = [];
						x.tweet.extended_entities.media.forEach((m,mi)=>{
							// 「/」で分割→末尾を取得 でパスの後半が分かる
							const sl = m.media_url.split('/');
							const imageName = `data/tweet_media/${x.tweet.id}-${sl[sl.length - 1]}`;
							x.tweet.customImg.push(imageName);
						})
					}

					// 配列の中が1階層余計なので省いてから格納
					this.twDataSorted.push(x.tweet);
				});

				// --------------------------------------------------
				// ソートと加工 ここまで
				// --------------------------------------------------

				this.twDataSorted.forEach(function (x,i) {
					if (x.in_reply_to_status_id) {
						try {
							// 返信先が有れば親を探しに行く(配列の末尾とは限らないので注意)
							let parent = this.twDataSorted.filter(bf => bf.id === x.in_reply_to_status_id);

							// ここは必ず1件ある想定。取れなければ次へ
							if (parent.length === 0) {
								return
							} else {
								parent = parent[0]
							}

							// 親リストにあるか(あれば1件のみ取れる想定)
							let threadParentIndex = -1;
							this.twDataFormatted.forEach(function(val,i){
								if (val.id === parent.id) {
									threadParentIndex = i
								}
							}.bind(this));

							if (threadParentIndex > -1) {
								// ある→子供リストを作って格納(子の一番最初)
								this.twDataFormatted[threadParentIndex].childrenList.push(x);
								this.twDataFormatted[threadParentIndex].childrenIdList.push(x.id);

							} else {
								// 無い→子供リストを探していく
								
								this.twDataFormatted.forEach(function (pr, i) {
										pr.childrenIdList.forEach(function (ch, j) {
											if (ch !== x.in_reply_to_status_id) {
												return
											}

											this.twDataFormatted[i].childrenList[j].childrenList.push(x);
											this.twDataFormatted[i].childrenList[j].childrenIdList.push(x.id);
										}.bind(this))
									}.bind(this));

								// threadParent = this.twDataFormatted.forEach(pr => {
								// 	console.log(pr.childrenIdList);
								// });

								// まずは childrenIdList の中にidが入っているスレッドの一番親元を探す
								// threadParent = this.twDataFormatted.filter(pr => {
								// 	console.log(pr);
								// 	if (pr.childrenIdList.filter(pc => pc === x.in_reply_to_status_id).length === 1) {

								// 	}
								// });

								// if (threadParent.length === 1)								console.log(threadParent);



								// let parentChildren = null;
								// while (parentChildren === null || !parentChildren.id) {
								// 	parentChildren = this.searchParentFromChildrenList()
								// }
							}
						} catch (err) {
							console.log(`err:[${i}]`);
							console.log(err);
						} finally {}
					} else {
						// 返信先が無ければ格納(親)
						this.twDataFormatted.push(x);
					}
				}.bind(this));

				// 最後の最後に日付を降順に戻す
				this.twDataSorted = this.twDataSorted.sort(function (a, b) {
					if (new Date(a.created_at) > new Date(b.created_at)) {
						return -1;
					} else {
						return 1;
					}
				});
				this.twDataFormatted = this.twDataFormatted.sort(function (a, b) {
					if (new Date(a.created_at) > new Date(b.created_at)) {
						return -1;
					} else {
						return 1;
					}
				});
			},
			methods: {
				formatDate: function (str) {
					const d = new Date(str);
					// YYYY/MM/dd(ddd) HH:mm:ss
					return `${d.getFullYear()}/${d.getMonth().toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}(${'日月火水木金土'[d.getDay()]}) ${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}:${d.getSeconds().toString().padStart(2, '0')}`;
				},
				ToggleReadMe: function () {
					this.isReadMe = !this.isReadMe;
				},
				ShowMessage: function () {
					return this.isReadMe ? '説明を閉じる' : '説明を開く';
				},

				// 子供リストの中から返信元を探す１
				searchParentFromChildrenList () {
				},
			},
		});
	</script>
</body>

</html>